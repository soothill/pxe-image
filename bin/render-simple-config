#!/usr/bin/env python3
# Copyright (c) 2024 Darren Soothill
"""Render configuration JSON from simple text files."""
from __future__ import annotations

import argparse
import json
import shlex
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional


@dataclass
class RepoSpec:
    owner: str
    repo: str
    path: str = "authorized_keys"
    ref: str = "main"


def read_lines(path: Path) -> List[str]:
    if not path.exists():
        return []
    content = path.read_text(encoding="utf-8")
    return [line.rstrip() for line in content.splitlines()]


def parse_packages(path: Path) -> List[str]:
    packages: List[str] = []
    for line in read_lines(path):
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        packages.append(stripped)
    return packages


def parse_services(path: Path) -> List[str]:
    services: List[str] = []
    for line in read_lines(path):
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        services.append(stripped)
    return services


def parse_repo_spec(spec: str, lineno: int) -> RepoSpec:
    ref = "main"
    if "@" in spec:
        spec, ref = spec.rsplit("@", 1)
        ref = ref or "main"
    path = "authorized_keys"
    if ":" in spec:
        repo_part, path = spec.split(":", 1)
        path = path or "authorized_keys"
    else:
        repo_part = spec
    if "/" not in repo_part:
        raise ValueError(f"Line {lineno}: repository specification '{spec}' must include owner/repo")
    owner, repo = repo_part.split("/", 1)
    if not owner or not repo:
        raise ValueError(f"Line {lineno}: repository specification '{spec}' is invalid")
    return RepoSpec(owner=owner, repo=repo, path=path, ref=ref)


def ensure_user_defaults(user: Dict[str, object]) -> None:
    user.setdefault("gecos", user["username"])
    user.setdefault("shell", "/bin/bash")


def parse_user_line(line: str, lineno: int) -> Dict[str, object]:
    tokens = shlex.split(line, comments=True, posix=True)
    if not tokens:
        raise ValueError(f"Line {lineno}: empty user definition")
    if len(tokens) < 3:
        raise ValueError(
            f"Line {lineno}: expected 'username password repo[:path][@ref] [additional ...]'"
        )

    username = tokens[0]
    raw_password = tokens[1]
    password_is_hashed = False
    if raw_password in {"-", "none", "null"}:
        password: Optional[str] = None
    elif raw_password.startswith("hash:"):
        password = raw_password.split(":", 1)[1]
        password_is_hashed = True
    else:
        password = raw_password

    user: Dict[str, object] = {
        "username": username,
        "github_keys": [],
    }
    if password:
        user["password"] = password
        if password_is_hashed:
            user["password_is_hashed"] = True

    for token in tokens[2:]:
        if "=" in token:
            key, value = token.split("=", 1)
            key = key.strip()
            value = value.strip()
            if key in {"gecos", "shell", "home"}:
                user[key] = value
            elif key in {"uid", "gid"}:
                try:
                    user[key] = int(value)
                except ValueError as exc:
                    raise ValueError(f"Line {lineno}: {key} must be an integer") from exc
            elif key == "github_user":
                user.setdefault("github_keys", []).append({"type": "user", "user": value})
            elif key == "github_url":
                user.setdefault("github_keys", []).append({"type": "url", "url": value})
            else:
                raise ValueError(f"Line {lineno}: unsupported attribute '{key}'")
        else:
            repo_spec = parse_repo_spec(token, lineno)
            user.setdefault("github_keys", []).append(
                {
                    "type": "repo",
                    "owner": repo_spec.owner,
                    "repo": repo_spec.repo,
                    "path": repo_spec.path,
                    "ref": repo_spec.ref,
                }
            )

    if not user["github_keys"]:
        raise ValueError(f"Line {lineno}: at least one GitHub key source must be provided")

    ensure_user_defaults(user)
    return user


def parse_users(path: Path) -> List[Dict[str, object]]:
    users: List[Dict[str, object]] = []
    for lineno, line in enumerate(read_lines(path), start=1):
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        users.append(parse_user_line(line, lineno))
    return users


def render_config(users: List[Dict[str, object]], packages: List[str], services: List[str]) -> Dict[str, object]:
    config: Dict[str, object] = {
        "packages": packages,
        "services": {
            "enable": services,
            "disable": [],
        },
        "users": users,
    }
    return config


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Render JSON configuration from simple text files")
    parser.add_argument("--users", type=Path, default=Path("config/users.txt"), help="Path to the users definition file")
    parser.add_argument(
        "--packages", type=Path, default=Path("config/packages.txt"), help="Path to the packages list"
    )
    parser.add_argument(
        "--services", type=Path, default=Path("config/services.txt"), help="Path to the services list"
    )
    parser.add_argument(
        "--output", type=Path, required=True, help="Destination JSON file that will be created or overwritten"
    )
    return parser.parse_args(argv)


def main(argv: Optional[Iterable[str]] = None) -> int:
    args = parse_args(argv)

    try:
        users = parse_users(args.users)
    except ValueError as exc:
        raise SystemExit(str(exc))

    packages = parse_packages(args.packages)
    services = parse_services(args.services)

    config = render_config(users, packages, services)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(json.dumps(config, indent=2) + "\n", encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
